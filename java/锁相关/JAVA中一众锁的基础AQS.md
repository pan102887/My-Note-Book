# AbstractQueueSynchronizer (AQS)

## 介绍

AQS提供了一种用于实现依赖于等待队列(FIFO)的阻塞锁和相关同步器（如信号量，事件......）的框架。该类可以成为大多数依赖于用单个原子int值表示状态的同步器的基础（基类）。子类中必须定义一个线程安全的方法用于修改该状态变量的值，并且它需要定义该状态变量什么时候表示该对象被获取或释放。基于这些，该类中的其他方法负责实现（carry out）所有的队列管理和阻塞机制。子类中还可以维护其他状态变量，但只有这个被`getState`,`setState`和`compareAndSet`方法访问的这个原子更新的int状态变量才会被用于同步相关的跟踪。

子类应该定义为非公有的内部helper类，用于实现器外部类的同步属性。`AQS`类不实现任何同步接口，而是定义了例如`acquireInterruptibly`这样的方法，具体的锁和相关的同步器可以根据需求调用这些方法实现他们的公共方法。

该类支持默认的独占模式和共享模式中的一种或两种。当以独占模式获取时，其他线程尝试获取资源将无法成功。而以共享模式获取时，多个线程可能（但不一定）能够成功获取。该类并不‘理解’这些模式的差异，除了在机械层面上：当共享模式获取成功时，下一个等待线程（如果存在）也必须判断它是否能够获取资源。等待线程（无论是独占模式还是共享模式）共享同一个FIFO队列。通常，子类实现只支持其中一种模式，但在某些情况下，例如在ReadWriteLock中，两种模式都可能同时发挥作用。仅支持独占模式或仅支持共享模式的子类无需定义支持未使用模式的方法。

该类定义了一个嵌套类 AbstractQueuedSynchronizer.ConditionObject，它可以作为支持独占模式的子类的 Condition 实现。对于这种子类，方法 isHeldExclusively 用于报告当前线程是否独占同步状态，方法 release 使用当前的 getState 值完全释放该对象，而方法 acquire 在给定保存的状态值后，最终将该对象恢复到之前的获取状态。AbstractQueuedSynchronizer 的其他方法不会创建这样的条件对象，因此如果无法满足这些约束，请不要使用它。AbstractQueuedSynchronizer.ConditionObject 的行为当然取决于其同步器实现的语义。

## 详解
