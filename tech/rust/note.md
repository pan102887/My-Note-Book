# 1. RUST笔记
- [1. RUST笔记](#1-rust笔记)
  - [1.1. rust中的数据行为](#11-rust中的数据行为)
  - [1.2. 可变引用与不可变引用](#12-可变引用与不可变引用)

## 1.1. rust中的数据行为  

在rust中，定长的数据类型如int, float, char这些在`编译时可以知道大小`的数据，它们被创建时存储在栈中。它们的行为和其他大多数编程语言中的数据行为一样

```rust
let v1 = 5;
let v2 = s1;
// 在这里将v1拷贝到v2上，也就是说在栈中有两个5被入栈
```

但如string这些在编译时并不能知道其大小的数据，在“拷贝”操作上则有不同。

```rust
let s1 = String::from("ABCDEF");
let s2 = s1;
// 此处将s1“拷贝”到s2（和浅拷贝类似）
```

上面代码中将s1“浅拷贝”到s2，但是完成“拷贝”后，`s1将失效`。

这是rust为了解决浅拷贝到来的`二次释放`问题。

在一般浅拷贝中, 变量可以认为是一个指向数据的指针。拷贝过程则是将一个指针的相关内容拷贝到另一个指针上，但是两个指针指向的数据都是同一块地址上的数据。此时便会有可能产生二次释放的问题。通常为了解决这个问题都会通过`引用计数`来记录当前指向数据的指针数量。当`引用计数`等于0时释放数据并回收地址空间。

但rust中不允许多个指针指向同一个数据，当进行`浅拷贝`操作后，原指针则会失效。保证只有一个指针指向数据。因此当进行数据释放操作时则不需要考虑二次释放问题。

## 1.2. 可变引用与不可变引用  

在rust中，对变量的操作有引用和借用