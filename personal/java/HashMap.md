# 1. 是什么
线程不安全的哈希表，可以快速的检索，插入和删除元素，并在理想情况下达到常数级别的时间复杂度O(1)
# 2. 什么使用场景
- 需要快速查找，插入和删除操作时
- 对数据的访问模式为读多写少时

# 3. 什么核心机制
1. [哈希算法](../算法/Hash算法.md)
2. 负载因子，扩容
## 3.1. 工作原理
- 对key使用hash(Object o)方法计算哈希值，这个哈希值用于确定键值对在哈希表中的存储位置。
- 使用数组或者红黑树（java8以上，若同一个hash值的位置存储数量超过8，则转化为红黑树）进行存储键值对. 因为存储的是键值对，因此hash冲突时这里使用链地址法处理。
- **负载因子（已存储的键值对数量/数组长度）**——为了保证哈希表的性能，当负载因此超过阈值时，会进行resize，并将数组中元素rehashing后重新存储到resize后得到的新数组中。
## 3.2. 性能
- 默认hash方法: key -> (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
- 线程不安全

# 4. 解决什么问题（什么特点）
- **快速访问元素**：理想的情况下（负载因子比较低，没有出现hash冲突）可提供常数级时间复杂度的查询，插入和删除操作。
- **允许空值**：允许Null作为Key或者value
- 无序的
# 5. 常见问题有哪些
## 5.1. 和HashTable有哪些区别
### 5.1.1. 线程安全
- HashTable每个method都是线程安全（同步的——每个方法都使用了Synchronized修饰），HashMap不是
### 5.1.2. null key和value
- HashTable中不允许null作为key或者value，而HashMap中允许一个key为null或多个key的value为null
### 5.1.3. 数据结构
- 在java8及以上版本中，HashMap使用了数组+链表+红黑树的数据结构，当链表长度超过8，将转换为红黑树以提高搜索效率
- HashTable中仅使用了数组+链表，没有使用红黑树优化
### 5.1.4. 迭代器
- HashTable中使用了Enumeration迭代器，它不会在迭代过程中检测到HashTable的结构变化。
- HashMap 使用Iterator迭代器，它是一个快速失败的迭代器，如果在使用迭代器期间HashMap的结构发生了变化，迭代器会抛出ConcurrentModificationException。
### 5.1.5. 扩展性
- HashMap 允许在构造时指定初始容量和负载因子，这有助于优化空间使用和性能。
- HashTable 的容量和负载因子是固定的，不能在构造时指定。