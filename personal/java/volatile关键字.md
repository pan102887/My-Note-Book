# 并发编程的核心
在讲述volatile的作用之前，这里先就并发编程的三大核心问题铺垫一下。如何保证原子性，可见性，有序性是并发编程中的三大核心问题。

1. 原子性：是指一个操作是不可被中断，但是在多线程环境下，由于线程的调度，CPU的上下文切换，线程内的多个操作是不能保证被原子执行的。
2. 可见性：是指当多个线程访问同一个变量时，一个线程修改了该变量的值，其他线程能立即看到修改后的值。
3. 有序性：即程序的执行按照代码中给出的先后顺序执行。现代的处理器和编译器为了提高程序运行的效率，可能会对代码的执行顺序进行优化（重排序），它不保证程序中各个语句的执行先后顺序是与代码中一致的，但会保证程序最终执行的结果与顺序执行的结果是一样的。

```java
    int a = 10; // 语句1
    int b = 20; // 语句2
    a += 11;    // 语句3
    b *= 2;     // 语句4
```
例如上面的代码中，指令重排可能会使执行顺序为: 1——3——2——4，或者是 1——2——4——3，这些执行顺序都能使最终的执行结果与 1——2——3——4顺序执行的结果相同。

```java
int a = 10; // 语句1
int b = 5;  // 语句2
a += 3;     // 语句3
r *= a;     // 语句4
```
在这段代码中，执行的顺序可能是 2——1——3——4,也可能是1——2——3——4，但不可能是2——1——4——3，也不可能是1——2——4——3。因为这里语句4依赖语句3的执行结果，在进行指令重排时，会考虑到指令之间的依赖关系。

```java
// 线程1
boolean inited = false;
context = loadContext();
inited = true

// 线程2
while (!inited) sleep();
doSomething(context);
```

但是在多线程环境中情况就不一样了，由于线程1中context与inited这两者之间，在代码字面上并没有依赖关系，因此线程1中发生指令重排后可能会导致先执行`inited = true`,再执行`loadContext()`，最终最终导致线程2在执行`doSomething`时，context可能并未完成初始化，从而引发错误。

# JMM(Java Memory Model)java内存模型
在JAVA中，为了屏蔽各种不同硬件平台和操作系统的内存访问差异，JMM规范了java虚拟机与计算机内存协同工作的流程。

![工作流程图](./imgs/JMM_MODULE.png)

如上图所示，当一个线程要访问某个共享变量时，要先将其从主内存中拷贝一份到工作内存中，操作完成后再将其回写到主内存中，而不能直接操作主内存中的变量。因此不同线程之间是无法互相访问对方的工作内存的，线程间的通信依赖主内存完成。因此显而易见，在多线程环境下，对同一个变量进行访问可能会发生线程安全问题（即使不是java，也会因为CPU的缓存架构产生相同的问题）$^{[1]}$


在java中，volatile关键字主要提供了`可见性`与`有序性`两个能力。
1. 可见性：被volatile修饰的共享变量被一个线程修改后，其新的值总是可以被其他线程立即感知到。
2. 有序性：可以禁止指令重排优化

# 可见性


1. [Java 并发编程之 JMM & volatile 详解](https://xie.infoq.cn/article/8b877b5fbe755c382fcee8ddd)