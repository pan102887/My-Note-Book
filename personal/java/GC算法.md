# JVM中的GC算法

当前市面上商业JVM的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，所谓分代收集，实际上就是一套符合大多数程序运行实际情况的经验，它建立在两个分代假说上：  

1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次数垃圾收集过程的对象就越难以消亡。

于是这两个假说就共同奠定了多款常用垃圾收集器的一致的设计原则：收集器应该将java堆划分出不同的区域，然后将回收对象依据年龄（即对象熬过垃圾回收过程的次数）分配到不同的区域中存储。java堆划分出不同的区域之后，垃圾收集器于是可以每次只回收其中某个或者某些部分区域，因此才有了“Minor GC” 、“Major GC”、“Full GC”这样不同的回收类型；

常见的垃圾收集算法有“标记清除法”、“标记复制法”、“标记整理法”这几种。

## 标记-清除法
最早出现也是最基础的垃圾收集算法是标记-清除（Mark-Sweep）算法，在1960年由lisp之父John McCarthy提出。它的工作过程可以分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后，统一回收掉所有被标记的对象。或者标记所有存活的对象，统一回收没有被标记过的对象。

它的缺点主要有两个：
1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时需要大量的标记和清除工作。因此工作效率随着对象数量的增加而降低。
2. 存在内存空间碎片化问题，标记清除之后回产生大量不连续的内存碎片，空间碎片太多可能会导致后续程序运行过程中需要分配较大对象是无法找到足够的连续内存而提前出发GC动作。


## 标记-复制算法
为了解决标记-清除算法内存碎片化以及面对大量对象时效率低的问题，1969年Fenichel提出了一种称为“半区复制”(Semispace Copying)的垃圾收集算法，它将可用内存划分成大小相等的两块区域，每次只是用其中的一块，当这一块用完了，就将还存活复制到另一块上面，再将这块用已使用过的内存空间一次清理掉。

但是如果内存中大多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但是对于多数对象都是可回收的情况，算法需要复制到额就时占少数的存活对象，并且不会产生内存碎片。但是缺点也非常明显，可用的内存只有实际内存的一半，内存空间比较浪费。但现在商用的JVM大多数都有限采用了这种收集算法回收新生代。

