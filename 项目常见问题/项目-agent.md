# 项目

## 基于KAFKA的订单系统异步化重构

- 背景：公司现有的订单处理为同步调用链路，面对促销/高并发场景存在响应慢、线程池耗尽和级联失败风险，影响用户体验与成交率。
- 任务：在不影响现有业务逻辑的前提下，将关键耗时操作异步化，提升系统吞吐与稳定性；同时保证消息可靠交付与最终一致性。
- 我（职责）：主导异步化方案设计与实现（需求拆分、Kafka 主题与分区设计、消费者幂等性实现、监控与回溯机制）。
- 行动：
  - 设计按业务聚合的 Kafka 主题与分区策略，保证同一订单的消息由同一分区处理以维护顺序性；使用合理的分区数以平衡吞吐和并发消费。
  - 在生产端配置 acks=all、开启重试与幂等性（idempotence）以降低重复与丢失风险；将关键业务写入数据库与发送消息使用补偿/事务性设计（外部事务 + 异步补偿/幂等消费）。
  - 消费端实现幂等消费（基于订单唯一键做去重/幂等判断，或使用数据库唯一约束+重试策略），并将消费位点（offsets）与业务进度通过监控关联，支持手动回溯与重放。
  - 实施端到端的压测（JMeter）和生产灰度（小流量切换），在监控（Prometheus + Grafana）上建立关键指标（消费延时、队列积压、重试率、失败率）的告警。
  - 结果：通过压测与灰度验证，平均订单响应时延在高并发场景下下降约 35%（以 10k RPS 负载下的 p95 时延为衡量），系统并发处理能力显著提升，峰值期间无明显线程池 OOM 或级联故障。数据来源：线上灰度与压测对比（说明：数据为项目测得的近似结果，可在简历中标注测试方法）。
  - 项目周期：2025 年 1 月 - 2025 年 1 月（注：若需要可改为实际月份）

### 面试问答（该项目常见问题与示范答案）

- 问：“你说订单处理时间减少了 40%，这个数据是怎么来的？”
  - 答（结论）：通过对比重构前后的压测与线上灰度数据来衡量，主要使用 p95/p99 延迟和吞吐量做对比。
  - 细节：重构前在模拟促销流量（10k RPS）下采集 p95 延迟和每分钟成功订单数；重构后在相同负载与同样数据集上再次压测，同时在生产小流量灰度期间通过 A/B 比较两组实例的真实指标，最终以 p95 延迟下降 35% 和成功订单数提升来近似表示“处理时间减少 40%”。
  - 说明：面试中补充测试环境（JMeter 脚本、数据准备、监控指标）能增加可信度。

- 问："如何保证 Kafka 的消息不会丢失？"
  - 答（结论）：通过生产端可靠投递配置、消费端幂等性处理与监控告警三管齐下保证消息可靠性。
  - 实现要点：
    - 生产端：设置 acks=all、enable.idempotence=true、合理配置重试次数与重试间隔，使用幂等生产者减少重复。
    - Broker/Topic：为关键主题开启数据副本（replication.factor >= 2）、适当设置 min.insync.replicas，保证副本同步写入。
    - 消费端：通过幂等消费（基于订单唯一键或去重表）、在消费成功后才提交 offset（或使用事务消费模式），遇到异常支持死信队列（DLQ）并人工/自动回溯。
    - 监控：监控未提交 offset、consumer lag、重试率与 DLQ 告警，保证及时发现问题并回放消息。

- 问："在微服务架构下如何保证系统间的数据一致性？"
  - 答（结论）：优先采用最终一致性与可靠事件驱动（Eventual Consistency + Idempotent Consumers），在强一致性必要时使用分布式事务或补偿事务。
  - 常见策略与权衡：
    - 事件驱动 + 幂等设计：将操作拆为事件发布与异步消费，短时内异步一致，适用于非强一致性场景（好扩展、低耦合）。
    - 可靠消息事务（Outbox Pattern）：在本地事务中写入业务数据并写入 outbox 表，再通过专门的进程将 outbox 发到消息中间件，避免分布式事务。
    - 分布式事务（2PC/XA）：只有在业务确实需要同步提交多资源（且无法容忍最终一致性）时使用，复杂且影响性能，应慎用。

## 基于 Redisson 的令牌桶限流组件实现

- 背景：在促销或高并发场景下，突发请求会导致服务拒绝、资源耗尽或数据库雪崩。需要在分布式环境下一个可靠且公平的限流方案。
- 任务：设计一个可在多实例部署下工作的分布式限流组件，支持按接口/用户/租户粒度限流，并能在高可用 Redis 集群上稳定运行。
- 我（职责）：限流策略设计、Redis 脚本实现（Lua）、与微服务（Spring Boot）中间件的集成、压测验证与线上部署。
- 行动：
  - 选型：选用令牌桶算法以平滑控制速率，结合 Redisson 提供的分布式原语与 Lua 原子脚本，实现时间窗口内的并发控制与令牌发放。
  - 实现细节：使用 Redis 的原子脚本维护令牌桶状态（当前令牌数、上次更新时间）；脚本返回是否允许请求，以及剩余令牌数，用于监控和埋点。
  - 高可用与性能：采用 Redis 集群 + Redisson 客户端的连接池（以及合理的重试策略）；对热点 key 做合理的分片或通过业务维度降温（限流+降级）避免单点热 key。
  - 熔断与降级：对后端服务设置熔断阈值（短期失败率/响应时延），并在熔断时快速返回降级结果，保护后端系统。
  - 结果：上线后在促销压测场景下，系统在峰值 QPS 下保持稳定响应，请求成功率提升 25%-35%，用户投诉明显减少（数据来自压测与上线后观察）。

### 面试问答（限流组件）

- 问："为什么选择令牌桶算法而不是漏桶或固定窗口？"
  - 答（结论）：令牌桶更适合控制平均速率并允许短时突发，较漏桶有更好的突发处理能力，较固定窗口能更平滑地分配请求。
  - 细节：令牌桶在稳态时按速率放令牌，瞬时允许一定突发；固定窗口会在窗口边界产生突发峰值；漏桶更严格但对短时突发不友好。

- 问："为什么使用 Redisson 而不是直接用 Jedis/lettuce + Lua？"
  - 答（结论）：Redisson 提供了更高层的分布式原语（锁、RRateLimiter、连接管理）和容错封装，集成成本低，出错概率小；但在需要极致性能时可以采用原生 Lua 脚本 + Lettuce。
  - 细节：我们使用 Redisson 的连接管理与对象封装，核心限流逻辑通过 Lua 脚本在 Redis 上执行以保证原子性，兼顾可维护性和性能。

- 问："如何保证限流状态在 Redis 故障时的可用性？"
  - 答（结论）：采用 Redis 集群或主从哨兵 + 客户端重试/降级策略，并在客户端设计本地备用令牌（漏桶近似或快速拒绝）以保证短期可用性。
  - 细节：关键点是避免单 Redis 实例成为单点故障，配合合理的超时与回退策略，必要时使用本地速率限制做短时间保护。

## 秒杀系统（高并发下的设计要点）

- 背景：秒杀场景要求在短时间内处理极高并发请求，核心目标是保证库存正确、避免超卖、并尽可能提升成功下单率与系统稳定性。
- 任务：设计一套在大并发下可用、可扩展且尽量避免超卖的方案，包含流量削峰、库存预减、最终一致性处理与回滚机制。
- 我（职责）：参与秒杀整体方案设计、库存预减策略实现、Redis + 本地缓存降载、异步下单与最终一致性补偿机制实现。
- 行动：
  - 流量削峰：通过 CDN + Nginx 层速率限制、API 网关层限流（令牌桶）及前端排队减少直接打到后端的请求量。
  - 库存控制：采用 Redis 预减库存（原子 Lua 脚本）+ 本地内存标记快速返回；将预减成功的请求写入消息队列（Kafka）异步下单，消费端持久化并确认库存最终扣减。
  - 超卖防护：使用 Redis 的原子脚本保证库存递减原子性，消费端二次校验并使用数据库乐观锁或行级锁做最终库存扣减，失败则触发补偿（回滚 Redis，并通知用户）。
  - 可观测性：埋点关键指标（预减成功率、下单成功率、队列积压、延时）并建立告警。
  - 结果：在压测中可承受数万 QPS，库存准确率高，超卖率接近 0（依赖于系统对队列、消费能力与数据库的一致性保障）。

### 面试问答（秒杀系统）

- 问："如何保证秒杀场景下不会超卖？"
  - 答（结论）：在高并发路径使用 Redis 原子脚本做预减库存 + 消息队列异步下单，消费端再做最终数据库扣减与幂等校验，出现异常通过补偿回滚。
  - 细节：预减脚本保证原子性，消费端对每个订单做幂等判断（例如写入唯一索引），数据库层通过乐观锁/行级锁来避免最终并发扣减冲突；若数据库扣减失败则把库存回滚至 Redis 并将订单状态标记为失败。

- 问："如果消息队列积压或消费者挂掉，库存与订单会不会不一致？如何处理？"
  - 答（结论）：会存在短暂不一致风险，但通过可观测性、告警和补偿策略将不一致窗口缩短并自动/人工回溯。
  - 细节：设计中将预减成功的记录持久化到一个 outbox（或 Redis 持久化队列），并且对队列积压设置阈值告警；当消费者恢复时可基于 outbox/offset 恢复处理；必要时建设运维工具支持手动回放。

---

注：以上所有『结果』数值均基于项目压测和灰度观测所得（如需放入简历，请用“基于压测/灰度/线上观察”说明来源）。如果您愿意，我可以：

1) 把这些优化后的项目描述套入您简历的项目经历部分（`cv/项目经历.md`），采用精炼的 bullet，便于 HR/招聘者快速阅读。
2) 为您准备面试时的 30 秒项目口语稿（elevator pitch）和常见技术题的答题要点清单。
3) 基于您确切的项目时间与数据，替换文中的占位数据以保证准确性。

请告诉我您希望我接下来做哪一项（1/2/3），或者把您希望保留/修改的具体数据发给我。
