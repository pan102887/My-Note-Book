# Rust的所有权

## 什么是所有权

"所有权"是Rust的内存管理方式，别的语言有的使用垃圾回收的方式进行管理（Java），有的语言则需要程序员显式地分配和释放内存（C）,Rust则使用与之都不同的第三种方式进行内存管理。

Rust通过一种所有权的规则系统堆内存进行管理，并且该系统在编译期间会对所有权的合法性进行检查。（不符合规则的代码会引起panic）

> ## Rust中的堆和栈
> 很多编程语言通常不需要程序员去考虑堆和栈的细节。但是在一个系统编程语言中比如Rust，一个变量在堆中还是在栈中将会影响程序的行为，因此程序员需要为此考虑并做出一定的决定。在“所有权”这部分内容将会介绍Rust中堆和栈的关系，以下是一些简单的铺垫。
> 
> 堆和栈都是运行时可用内存中的一部分，但是他们的结构（访问方式）不一样。栈中的数据是后进先出（以获取值的顺序存储，并以相反的顺序删除）。略……
> **所有存存放在栈中的数据格式以及大小必须是编译时已知的，可变大小的数据必须存放在堆中**
>
> 堆中的内存组织方式相对于栈来说是松散的，当你要把一个数据放入堆中时，你需要先申请一块一定大小的内存空间。然后内存分配器会在堆中找到一块满足空间大小的内存区域，然后内存分配器返回一个指向这块空间的地址起点的指针。然后进程再将数据往这块空间中写入（往栈中写入数据则不需要考虑内存的分配问题，但是会有栈溢出的问题）。因为指向这块堆内存空间的指针类型与大小是已知的，因此你可以将这个指针存放在栈中。
>
>将数据写入栈中的速度要比写入堆中要快，因为在堆中需要内存分配器为数据去寻找合适的内存空间，但是向栈中存放数据则总是在栈的顶部进行操作。因此对比两者，区别就是在堆中分配空间需要更多的工作，因为内存分配器需要找到一个足够大的空间用来保存数据，然后将这块空间登记。
>
>访问堆中的数据也是比访问栈中的数据要慢的，因为访问堆中的数据需要根据指针进行间接寻址，才能定位到堆的位置，进程需要在内存中进行更多跳转，因此需要耗费更多的时间。打个比方就是，一个服务员在一个餐厅里为客户下单，通常都是先将一桌的单全部下好后，再去为另一桌客户下单。如果在A桌下单下到一半，突然又去B桌下单，接着又回到A桌继续下单，这样就会慢很多。和这个类似，程序在一块连续的内存上进行工作会比在不连续的很多块内存上进行工作要块。（前者是栈，后者是堆）
>
>当你在代码中调用一个函数，会将一些数据传递到方法（可能包括堆上的数据），然后函数内部的本地变量会被push到栈中，当函数运行结束，函数的本地变量会从栈中出栈
>
>跟踪代码中的哪些部分正在使用堆中的哪些数据，最大限度地减少堆上的重复数据，以及清理堆上未使用的数据，以避免空间不足，这些都是所有权解决的问题。了解所有权后，您就不需要经常考虑堆栈和堆，但是知道所有权的主要目的是管理堆数据可以帮助解释为什么它以这种方式工作。

## 所有权的规则

首先，先让我们看一下所有权规则，在通过说明这些规则示例时，请把这些规则记在脑中：
- 在Rust中的每个变量都有所有权。
- 一个变量的所有权只能同时有一个所有着。
- 当所有者超出范围时，所有者所拥有的数据的所有权将被释放。

## 变量作用域
现在我们已经过了Rust的基本语法，我们不会在示例代码中包含```fn main() {```，因此如果你需要运行示例代码，请确保将示例代码放在main方法中。因此我们的示例代码会比较简约，以此可以将注意力更多地集中在问题细节上而不是示例代码上。

第一个所有权的例子，我们将讨论变量的作用域，作用域时